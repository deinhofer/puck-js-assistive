//Turn on LED to indicate download
LED2.set();

//Write needed modules to Storage so that they can be imported afterwards.
require("Storage").write("SWButton","/* Copyright (c) 2014 Markus Muetschard. See the file LICENSE for copying permission. */\n\n/*\nSWBtn class - instances of SWBtn makes many buttons out of \njust one hardware button by detecting sequences of short and \nlong presses and passing them on to a user defined, dispatching \ncallback function.\n\nFor example, one long press of Espruino onboard BTN1 turns LED1 \non, and one long and one short turn it off. Two long presses and \ntwo long presses followed by a short one do the same to LED2, etc.\n\nEach detected sequence is passed in form of a string of \"S\"s \nand \"L\"s to the user provided callback function. The callback \nfunction uses the string as a key to call assigned functions\nlike dispatcher.\n\nNOTE: Works on 1v72+ due to export and usage pattern\n\nUsage examples:\n\n// 1st example just logs the key press pattern\nvar SWBtn = require(\"SWButton\");\nvar mySWBtn = new SWBtn(function(k){\n    console.log(\"BTN1 detected \" + k); // log key press pattern\n  });\n\n// 2nd example tests key pattern and executes accordingly\nvar SWBtn = require(\"SWButton\");\nvar mySWBtn = new SWBtn(function(k){\n    console.log(\"BTN1 detected \" + k); // log key press pattern\n    if        (k === \"L\"  ) { LED1.set();\n    } else if (k === \"LS\" ) { LED1.reset();\n    } else if (k === \"LL\" ) { LED2.set();\n    } else if (k === \"LLS\") { LED2.reset();\n    }\n  });\n\n// 3rd example avoids chained ifs by:\nvar functions = // function names match key press pattern\n{ L:   function(){ LED1.set();   }\n, LS:  function(){ LED1.reset(); }\n, LL:  function(){ LED2.set();   }\n, LLS: function(){ LED2.reset(); }\n};\nvar SWBtn = require(\"SWButton\");\nvar mySWBtn = new SWBtn(function(k){\n    console.log(\"BTN1 detected \" + k); // log detected key pattern and...\n    if (functions[k]) { functions[k](); }; // ...dispatch if defined\n  },BTN1,false);\n\n// 4th example assumes a push button on pin B2 connecting to +3.3\npinMode(B2,\"input_pulldown\");\nvar SWBtn = require(\"SWButton\");\nvar mySWBtn = new SWBtn(function(k){\n    console.log(\"Btn on B2 detected \" + k); // log key press pattern\n  },B2);\n\n*/\n\n/**\nSWBtn - SoftWare Butten 'class'\n- constructor - accepts these arguments:\n  - f - (optional) anonymous, one argument accepting dispatching callback function\n  - b - (optional) button/pin id - default is BTN1\n  - d - (optional) boolean interpreted disable flag - default false\n        Allows button to be creted in disabled state in order \n        for (other) initializations to complete before being\n        enabled with .disable(0) / .disable(false) / .disable()\n        method invocation.\n- instance properties:\n  - f - storex passed or set dispatching callback function\n  - b - storex button / pin id\n  - d - stores disabled (status) of button\n  - t - xgofdx timeout for sequence end / pause detection\n  - k - stores build-up key store holding on to the \"S\"s and \"L\"s of a squence\n  - w - stores hold on to the watch set with setWatch()\n*/\nvar SWBtn = function(f,b,d) {\n  this.f = (f) ? f : function(){};\n  this.b = (b) ? b : BTN1;\n  this.t = null;\n  this.k = null;\n  this.w = null;\n  this.disable(d);\n }\n\n/**\n.C - Constants / Configuration - defining the timings \n- shared by all instances of SWBtn:\n  - B - integer - debounce [ms]\n  - L - float   - min Long press [s]\n  - P - integer - min Pause [ms]\n  - D - integer - delay of fnc function invocation [ms]\n  Pressing a button / keeping a pin low for .C.L seconds or more is detected\n  as a long press when unpressed / released / pin turns high and and adds an \n  \"L\" to .k key (press sequnce) - otherwise a short press is detected and an \n  \"S\" is adde - and the .t timeout is set with .C.P Pause time and .e() ended\n  call back for press sequence end detection and processing (invocation of\n  user defined - ,k key decoding dispatch - function).\n*/\nSWBtn.prototype.C =\n  { B: 20\n  , L: 0.250\n  , P: 220\n  , D: 10\n  };\n\n/**\n.disable(b) - disables/enables button\n- method - accepts one argument\n  - b - boolean - (optional) boolean interpreted disable flag - default false\n  Used to (temporarily) disable the button (also used in constructor).\n  It clears/sets the hardware / pin watch using clearWatch() / setWatch() functions.\n  NOTE1: When button is disabled while press sequence is going on, sequence end is\n    not detected, but partial sequence is still stored in .k key property (but does \n    not include an ongoing press). \n  NOTE2: The .k key property is cleared (set to \"\") when button is (re-)enabled.\n  NOTE3: any passed parameter that evaluates to false in an 'if (parameter)' and \n    omission of parameter enable the button: .disable(false), .disable(0),\n    .disable(\"\"), .disable(''), .disable(null), .disable(undefined), and .disable(),\n    all these invocations enable the button... ;)\n*/\nSWBtn.prototype.disable = function(b) {\n  if (b) {\n    if (this.w) { \n      this.d = true;\n      clearWatch(this.w);\n      this.w = null; \n      if (this.t) {\n        clearTimeout(this.t);\n        this.t = null;\n      }\n    }\n  } else {\n    if (!this.w) {\n      this.d = false;\n      this.k = \"\";\n      var _this = this;\n      this.w = setWatch(function(e){ _this.c(e); }, this.b\n                 , { repeat:true, edge:\"both\", debounce:_this.C.B });\n    }\n  }\n };\n\n/**\n.c(e) - button/pin button/pin state change callback - invoked by Espruino\n- method - accepts one e event argument (object) \n  Espruino reference for .setWatch() defines e event object as:\n  - time     - float   - time of this state change [s]\n  - lastTime - float   - time of last such state change [s]\n  - state    - boolean - current state of the button / pin\n  Notes button/pin status and - on unpress/release state - \n  appends \"L\"(ong) or \"S\"(short) to .k key (sequence) and \n  sets .t timeout to .C.P Pause for sequence end detection\n*/\nSWBtn.prototype.c = function(e){ // change of state - called by set watch\n  if (e.state) {\n    if (this.t) {\n      clearTimeout(this.t);\n      this.t = null;\n    }\n  } else {\n    this.k = this.k + ((e.time - e.lastTime < this.C.L) ? \"S\" :\"L\");\n    var _this = this;\n    this.t = setTimeout(function(){ _this.e(); }, this.C.P);\n  }\n };\n\n/**\n.e() - sequence ended timeout callback - invoked by .t timeout set in .c(e)\n- method - accepts no arguments\n  Marks detected end of press sequence and invokes user provided .f \n  callback function in a setTimeout() with .C.D delay.\n*/\nSWBtn.prototype.e = function() {\n  this.t = null;\n  var _k = this.k;\n  if (_k.length > 0) {\n    this.k = \"\";\n    var _this = this;\n    setTimeout(function(){ _this.f(_k); },this.C.D);\n  }\n };\n\nexports = SWBtn;\n");
require("Storage").write("hid_","function l(a){for(var b=0;b<c.length;b++){if(c[b]==a)return;if(0==c[b]){c[b]=a;return}}for(b=0;b<c.length-1;b++)c[b]=c[b+1];c[c.length-1]=a}function m(a){if(-1==a)c.fill(0);else for(var b=0;b<c.length;b++)c[b]==a&&(c[b]=0)}exports.report=new Uint8Array([5,1,9,2,161,1,133,1,9,1,161,0,5,9,25,1,41,5,21,0,37,1,149,5,117,1,129,2,149,1,117,3,129,3,5,1,9,48,9,49,9,56,21,129,37,127,117,8,149,3,129,6,5,12,10,56,2,21,129,37,127,117,8,149,1,129,6,192,192,5,1,9,6,161,1,133,2,5,7,25,224,\n41,231,21,0,37,1,117,1,149,8,129,2,117,8,149,1,129,1,25,0,41,115,21,0,37,115,149,5,117,8,129,0,192]);exports.MODIFY={CTRL:1,SHIFT:2,ALT:4,GUI:8,LEFT_CTRL:1,LEFT_SHIFT:2,LEFT_ALT:4,LEFT_GUI:8,RIGHT_CTRL:16,RIGHT_SHIFT:32,RIGHT_ALT:64,RIGHT_GUI:128};exports.KEY={A:4,B:5,C:6,D:7,E:8,F:9,G:10,H:11,I:12,J:13,K:14,L:15,M:16,N:17,O:18,P:19,Q:20,R:21,S:22,T:23,U:24,V:25,W:26,X:27,Y:28,Z:29,1:30,2:31,3:32,4:33,5:34,6:35,7:36,8:37,9:38,0:39,ENTER:40,\"\\n\":40,ESC:41,BACKSPACE:42,\"\\t\":43,\" \":44,\"-\":45,\"=\":46,\n\"[\":47,\"]\":48,\"\\\\\":49,NUMBER:50,\";\":51,\"'\":52,\"~\":53,\",\":54,\".\":55,\"/\":56,CAPS_LOCK:57,F1:58,F2:59,F3:60,F4:61,F5:62,F6:63,F7:64,F8:65,F9:66,F10:67,F11:68,F12:69,PRINTSCREEN:70,SCROLL_LOCK:71,PAUSE:72,INSERT:73,HOME:74,PAGE_UP:75,DELETE:76,END:77,PAGE_DOWN:78,RIGHT:79,LEFT:80,DOWN:81,UP:82,NUM_LOCK:83,PAD_SLASH:84,PAD_ASTERIX:85,PAD_MINUS:86,PAD_PLUS:87,PAD_ENTER:88,PAD_1:89,PAD_2:90,PAD_3:91,PAD_4:92,PAD_5:93,PAD_6:94,PAD_7:95,PAD_8:96,PAD_9:97,PAD_0:98,PAD_PERIOD:99,ALL:-1};var e={NONE:0,LEFT:1,\nRIGHT:2,MIDDLE:4,BACK:8,FORWARD:16};e.ALL=e.LEFT|e.RIGHT|e.MIDDLE|e.BACK|e.FORWARD;exports.BUTTON=e;var f=0,c=new Uint8Array(5);exports.getHoldingButtons=function(){return f};exports.moveMouse=function(a,b,d,g,h,k){d||(d=f);g||(g=0);h||(h=0);NRF.sendHIDReport([1,d,a,b,g,h,0,0],function(){k&&k()})};exports.scroll=function(a,b,d){exports.moveMouse(0,0,f,a,b,d)};exports.holdButton=function(a,b){f|=a;exports.moveMouse(0,0,f,0,0,b)};exports.releaseButton=function(a,b){f&=~a;exports.moveMouse(0,0,f,0,0,\nb)};exports.clickButton=function(a,b){exports.holdButton(a,()=>exports.releaseButton(a,b))};exports.getHoldingKeys=function(){return c};exports.updateModifiers=function(a,b){a||(a=0);NRF.sendHIDReport([2,a,0,c[0],c[1],c[2],c[3],c[4]],function(){b&&b()})};exports.keyDown=function(a,b,d){Array.isArray(a)||(a=[a]);a.forEach(l);exports.updateModifiers(b,d)};exports.keyUp=function(a,b){Array.isArray(a)||(a=[a]);a.forEach(m);exports.updateModifiers(0,b)};exports.tapKey=function(a,b,d){exports.keyDown(a,\nb,()=>exports.keyUp(a,d))}");

//Very important!!
//Do reset to ensure clean state!!
//Otherwise there could be old timeouts and watchdogs configured
reset();